\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `mFLICA'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Title]\AsIs{mFLICA: Leadership-Inference Framework for Multivariate Time Series}
\item[Version]\AsIs{0.1.0}
\item[Description]\AsIs{A leadership-inference framework for multivariate time series. The framework uses a notion of a leader as an individual who initiates collective patterns that everyone in a group follows. Given a set of time series of individual activities, our goal is to identify periods of coordinated activity, find factions of coordination if more than one exist, as well as identify leaders of each faction. For each time step, the framework infers following relations between individual time series, then identifying a leader of each faction whom many individuals follow but it follows noone. A faction is defined as a group of individuals that everyone follows the same leader. mFLICA reports following relations, leaders of factions, and members of each faction for each time step. Please see Chainarong Amornbunchornvej and Tanya Berger-Wolf (2018) <doi:10.1137/1.9781611975321.62> when referring to this package in publications.}
\item[License]\AsIs{GPL-3}
\item[URL]\AsIs{}\url{https://github.com/DarkEyes/mFLICA}\AsIs{}
\item[BugReports]\AsIs{}\url{https://github.com/DarkEyes/mFLICA/issues}\AsIs{}
\item[Language]\AsIs{en-US}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[Depends]\AsIs{R (>= 3.5.0),
dtw}
\item[Imports]\AsIs{ggplot2 (>= 3.0)}
\item[Suggests]\AsIs{knitr, rmarkdown}
\item[VignetteBuilder]\AsIs{knitr}
\item[RoxygenNote]\AsIs{7.0.2}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{followingNetwork}{followingNetwork function}{followingNetwork}
%
\begin{Description}\relax
followingNetwork is a support function for calculating a following network of a set of time series
\end{Description}
%
\begin{Usage}
\begin{verbatim}
followingNetwork(TS, timeLagWindow, lagWindow = 0.1, sigma = 0.1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{TS}] is a set of time series where \code{TS[i,t,d]} is a numeric value of \code{i}th time series at time \code{t} and dimension \code{d}.

\item[\code{timeLagWindow}] is a maximum possible time delay in the term of time steps.

\item[\code{lagWindow}] is a maximum possible time delay in the term of percentage of time length of \code{TS}.

\item[\code{sigma}] is a threshold of following relation. It is used to discretize an adjacency matrix \code{adjWeightedMat} to be a binary matrix \code{adjBinMat}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns adjacency matrices of a following network of \code{TS}.

\begin{ldescription}
\item[\code{adjWeightedMat}]  An adjacency matrix of a following network
s.t. if \code{adjWeightedMat[i,j]>0}, then \code{TS[i,{},]} follows  \code{TS[j,{},]} with a degree \code{adjWeightedMat[i,j]}. 
\item[\code{adjBinMat}]  A binary version of \code{adjWeightedMat} s.t. \code{adjBinMat[i,j] <- (adjWeightedMat[i,j] >=sigma)} for any \code{i,j}.  
\end{ldescription}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Run the function

out<-followingNetwork(TS=mFLICA::TS[,60:90,],sigma=0.5)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{followingRelation}{followingRelation}{followingRelation}
%
\begin{Description}\relax
followingRelation is a function that infers whether \code{Y} follows \code{X}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
followingRelation(Y, X, timeLagWindow, lagWindow = 0.1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Y}] is a T-by-D matrix of numerical time series of a follower

\item[\code{X}] is a T-by-D matrix numerical time series of a leader

\item[\code{timeLagWindow}] is a maximum possible time delay in the term of time steps.

\item[\code{lagWindow}] is a maximum possible time delay in the term of percentage of length(X).
If \code{timeLagWindow} is missing, then \code{timeLagWindow=ceiling(lagWindow*length(X))}. The default is 0.2.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns a list of following relation variables below.

\begin{ldescription}
\item[\code{follVal}]  is a following-relation value s.t. if \code{follVal} is positive, then \code{Y} follows \code{X}. If  \code{follVal} is negative, then \code{X} follows \code{Y}.
Otherwise, if \code{follVal} is zero, there is no following relation between \code{X,Y}. 
\item[\code{dtwIndexVec}]  is a numeric vector of index-warping difference: dtwIndexVec[k] = dtwOut\$index1[k] - dtwOut\$index2[k] where dtwOut is the output from dtw::dtw(x=Y,y=X) function.
\end{ldescription}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Load example data

leader<- mFLICA::TS[1,1:200,]
follower<- mFLICA::TS[2,1:200,]

# Run the function

out<-followingRelation(Y=follower,X=leader)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getADJNetDen}{getADJNetDen function}{getADJNetDen}
%
\begin{Description}\relax
getADJNetDen is a support function for calculating a network density of a network.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getADJNetDen(adjMat)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{adjMat}] is an adjacency matrix of a dominant-distribution network.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns a value of network density of of a network for a given adjMat.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Given an example of adjacency matrix
A<-matrix(FALSE,5,5)
A[2,1]<-TRUE
A[c(3,4),2]<-TRUE

# Get a network density of an adjacency matrix

getADJNetDen(adjMat=A)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getDynamicFollNet}{getDynamicFollNet function}{getDynamicFollNet}
%
\begin{Description}\relax
getDynamicFollNet is a support function for calculating a dynamic following network of a set of time series
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getDynamicFollNet(TS, timeWindow, timeShift, sigma = 0.5, silentFlag = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{TS}] is a set of time series where \code{TS[i,t,d]} is a numeric value of \code{i}th time series at time \code{t} and dimension \code{d}.

\item[\code{timeWindow}] is a time window parameter that limits a length of each sliding window. The default is 10 percent of time series length.

\item[\code{timeShift}] is a number of time steps a sliding window shifts from a previous window to the next one. The default is 10 percent of \code{timeWindow}.

\item[\code{sigma}] is a threshold of following relation. The default is 0.5.

\item[\code{silentFlag}] is a flag that prohibit the function to print the current status of process.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns adjacency matrices of a dynamic following network of \code{TS} as well as the corresponding time series of network densities.

\begin{ldescription}
\item[\code{dyNetWeightedMat}]  An adjacency matrix of a dynamic following network
s.t. if \code{dyNetWeightedMat[i,j,t]>0}, then \code{TS[i,{},]} follows  \code{TS[j,{},]} at time \code{t} with a degree \code{dyNetWeightedMat[i,j,t]}. 
\item[\code{dyNetBinMat}]  A binary version of \code{dyNetWeightedMat} s.t. \code{dyNetWeightedMat[i,j,t] <- (dyNetWeightedMat[i,j,t] >=sigma)} for any \code{i,j,t}.  
\item[\code{dyNetWeightedDensityVec}] A time series of dynamic network densities of \code{dyNetWeightedMat}
\item[\code{dyNetBinDensityVec}] A time series of dynamic network densities of \code{dyNetBinDensityVec}
\end{ldescription}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Run the function
out<-getDynamicFollNet(TS=mFLICA::TS[,1:10,],timeWindow=5,timeShift = 5,sigma=0.5)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getFactions}{getFactions function}{getFactions}
%
\begin{Description}\relax
getFactions is a support function for inferring faction leaders and their memebers as well as a faction size ratio of each faction.
Leaders are nodes that have zero outgoing degree. Members of leader A's faction are nodes that have some directed path to A in a following network.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getFactions(adjMat)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{adjMat}] is an adjacency matrix of a following network.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns a list of leader IDs, a list of faction members, and network densities of factions.

\begin{ldescription}
\item[\code{leaders}]  is a list of faction leader IDs  
\item[\code{factionMembers}]  is a list of memebrs of factions where \code{factionMembers[[i]]} is a list of faction members of a leader \code{leaders[i]}'s faction. 
\item[\code{factionSizeRatio}]  is a vector of faction size ratio of each faction.
\code{factionSizeRatio[i]} is a number of edges within a leader \code{leaders[i]}'s faction divided by N choose 2 where N is a number of all nodes.
\end{ldescription}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Given an example of adjacency matrix
A<-matrix(FALSE,5,5)
A[2,1]<-TRUE
A[c(3,4),2]<-TRUE
A[5,3]<-TRUE
# Get faction leaders and their memebers as well as a network density of each faction.

out<-getFactions(adjMat=A)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getFactionSizeRatio}{getFactionSizeRatio function}{getFactionSizeRatio}
%
\begin{Description}\relax
getFactionSizeRatio is a support function for calculating a faction size ratio of a given faction.
A faction size ratio is a number of edges that connect between faction-member nodes divided by a number of total nodes within a following network.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getFactionSizeRatio(adjMat, members)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{adjMat}] is an adjacency matrix of a dominant-distribution network.

\item[\code{members}] is a list of member IDs of a given faction.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns a faction size ratio of a given faction.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# Given an example of adjacency matrix
A<-matrix(FALSE,5,5)
A[2,1]<-TRUE
A[c(3,4),2]<-TRUE

# Get a faction size ratio of a given faction

getFactionSizeRatio(adjMat=A,members=c(1,2,3,4))

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getReachibleNodes}{getReachibleNodes function}{getReachibleNodes}
%
\begin{Description}\relax
getReachibleNodes is a support function for inferring reachable nodes that have some directed path to a node \code{targetNode}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getReachibleNodes(adjMat, targetNode)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{adjMat}] is an adjacency matrix of a following network of which its elements are binary: zero for no edge, and one for having an edge.

\item[\code{targetNode}] is a node in a graph that we want to find a set of nodes that can reach this target node via some paths.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns a set of node IDs \code{followers} that have some directed path to a node \code{targetNode}.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Given an example of adjacency matrix
A<-matrix(FALSE,5,5)
A[2,1]<-TRUE
A[c(3,4),2]<-TRUE
A[5,3]<-TRUE
# Get a set of reachable nodes of targetNode.

followers<-getReachibleNodes(adjMat=A,targetNode=1)$followers

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{mFLICA}{mFLICA: leadership-inference framework for multivariate time series}{mFLICA}
%
\begin{Description}\relax
A leadership-inference framework for multivariate time series. The framework uses a notion of a leader as an individual who initiates collective patterns that everyone in a group follows. Given a set of time series of individual activities, our goal is to identify periods of coordinated activity, find factions of coordination if more than one exist, as well as identify leaders of each faction. For each time step, the framework infers following relations between individual time series, then identifying a leader of each faction whom many individuals follow but it follows noone. A faction is defined as a group of individuals that everyone follows the same leader. mFLICA reports following relations, leaders of factions, and members of each faction for each time step. Please see Chainarong Amornbunchornvej and Tanya Berger-Wolf (2018) <doi:10.1137/1.9781611975321.62> when referring to this package in publications.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mFLICA(TS, timeWindow, timeShift, sigma = 0.5, silentFlag = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{TS}] is a set of time series where \code{TS[i,t,d]} is a numeric value of \code{i}th time series at time \code{t} and dimension \code{d}.

\item[\code{timeWindow}] is a time window parameter that limits a length of each sliding window. The default is 10 percent of time series length.

\item[\code{timeShift}] is a number of time steps a sliding window shifts from a previous window to the next one. The default is 10 percent of \code{timeWindow}.

\item[\code{sigma}] is a threshold of following relation. The default is 0.5. Note that if \code{sigma} is not one, an individual might be a member of mutiple factions.

\item[\code{silentFlag}] is a flag that prohibit the function to print the current status of process.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns dynamic following networks, as well as leaders of factions, and members of each faction for each time step.

\begin{ldescription}
\item[\code{dyNetOut\$dyNetWeightedMat}]  An adjacency matrix of a dynamic following network
s.t. if \code{dyNetWeightedMat[i,j,t]>0}, then \code{TS[i,{},]} follows  \code{TS[j,{},]} at time \code{t} with a degree \code{dyNetWeightedMat[i,j,t]}. 
\item[\code{dyNetOut\$dyNetBinMat}]  A binary version of \code{dyNetWeightedMat} s.t. \code{dyNetWeightedMat[i,j,t] <- (dyNetWeightedMat[i,j,t] >=sigma)} for any \code{i,j,t}.  
\item[\code{dyNetOut\$dyNetWeightedDensityVec}] A time series of dynamic network densities of \code{dyNetWeightedMat}
\item[\code{dyNetOut\$dyNetBinDensityVec}] A time series of dynamic network densities of \code{dyNetBinDensityVec}
\item[\code{leadersTimeSeries}] A time series of leaders of each faction where \code{leadersTimeSeries[[t]]} is a set of leaders at time \code{t}. A number of factions is the same as a number of leaders.
\item[\code{factionMembersTimeSeries}] A time series of sets of faction memebers where \code{factionMembersTimeSeries[[t]][[k]]} is a set of faction-members at time \code{t} leading by a leader \code{leadersTimeSeries[[t]][k]}. 
\item[\code{factionSizeRatioTimeSeries}] A time series of faction-size ratios of all individuals. A faction size ratio is a number of edges that connect between faction-member nodes divided by a number of total nodes within a following network. If a leader has a higher faction-size ratio, then it has more followers than a leader with a lower faction-size ratio. A faction-size ratio has a value between 0 and 1.
\end{ldescription}
\end{Value}
%
\begin{Author}\relax
Chainarong Amornbunchornvej, \email{chai@ieee.org}
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}

# Run the function

obj1<-mFLICA(TS=mFLICA::TS[,60:90,],timeWindow=10,timeShift=10,sigma=0.5)

# Plot time series of faction size ratios of all leaders

plotMultipleTimeSeries(TS=obj1$factionSizeRatioTimeSeries, strTitle="Faction Size Ratios")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotMultipleTimeSeries}{plotMultipleTimeSeries}{plotMultipleTimeSeries}
%
\begin{Description}\relax
plotMultipleTimeSeries is a function for visualizing time series
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotMultipleTimeSeries(TS, strTitle = "Time Series Plot", TSnames)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{TS}] is a set of time series where \code{TS[i,t,d]} is a numeric value of \code{i}th time series at time \code{t} and dimension \code{d}.

\item[\code{strTitle}] is a string of the plot title

\item[\code{TSnames}] is a list of legend of \code{X,Y} where TSnames[1] is a legend of \code{X} and  TSnames[2] is a legend of \code{Y}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
This function returns an object of ggplot class.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Run the function
plotMultipleTimeSeries(TS=mFLICA::TS[1:5,1:60,1])

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{TS}{A simulation time series of movement coordination of 30 individuals}{TS}
\keyword{datasets}{TS}
%
\begin{Description}\relax
A dataset containing simulated trajectories of 30 individuals moving to form coordination in x-y coordinates.
In the interval [1,200], ID1 leads the group and everyone follows. ID2 leads the group during the interval [201,400].
Lastly, ID3 leads the group during the interval [401,600]. The interval [601,800] is the time when everyone trying to stop moving.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
TS
\end{verbatim}
\end{Usage}
%
\begin{Format}
An array with 30 rows of individuals, 800 columns of time steps, and 2 dimensions of coordinate (x,y):
\begin{description}

\item[TS]  It is a set of time series where \code{TS[i,t,d]} is a numeric value of \code{i}th time series at time \code{t} and dimension \code{d}.
...

\end{description}
\end{Format}
\printindex{}
\end{document}
