%\VignetteIndexEntry{mFLICA software paper}
%\VignetteEngine{R.rsp::tex}
%\VignetteKeyword{R}
%\VignetteKeyword{package}
%\VignetteKeyword{vignette}
%\VignetteKeyword{LaTeX}

\documentclass[nojss]{jss} % change it to article later

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\bfseries\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\usepackage[algo2e,titlenumbered,ruled]{algorithm2e} 

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newcounter{Lcount}
\newcommand{\numsquishlist}{
   \begin{list}{\arabic{Lcount}. }
    { \usecounter{Lcount}
 \setlength{\itemsep}{-.1ex}      \setlength{\parsep}{0ex}
      \setlength{\topsep}{0ex}       \setlength{\partopsep}{0ex}
      \setlength{\leftmargin}{1em} \setlength{\labelwidth}{1em}
      \setlength{\labelsep}{0.1em} } }
\newcommand{\numsquishend}{\end{list}}

\newcommand{\squishlist}{
   \begin{list}{$\bullet$}
    { \setlength{\itemsep}{-.1ex}      \setlength{\parsep}{0ex}
      \setlength{\topsep}{0ex}       \setlength{\partopsep}{0ex}
      \setlength{\leftmargin}{.8em} \setlength{\labelwidth}{1em}
      \setlength{\labelsep}{0.5em} } }
\newcommand{\squishend}{\end{list}}

\newtheorem{exmp}{Example}[section]

%% almost as usual
\author{Chainarong Amornbunchornvej\\National Electronics and Computer Technology Center}
\title{\pkg{mFLICA}: An \proglang{R} package for Inferring Leadership of Coordination From Time Series}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Chainarong Amornbunchornvej} %% comma-separated
\Plaintitle{mFLICA: An R package for Inferring Leadership of Coordination From Time Series} %% without formatting
\Shorttitle{\pkg{mFLICA}: An \proglang{R} package for leadership inference} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
  Leadership is a process that leaders influence followers to achieve collective goals. One of  special cases of leadership is the coordinated pattern initiation. In this context, leaders are initiators who initiate coordinated patterns that everyone follows. Given a set of individual-multivariate time series of real numbers, the \pkg{mFLICA} package provides a framework for \proglang{R} users to infer coordination events within time series, initiators and followers of these coordination events, as well as dynamics of group merging and splitting. The \pkg{mFLICA} package also has a visualization function to make results of leadership inference more understandable. The package is available on Comprehensive R Archive Network (CRAN) at \href{https://CRAN.R-project.org/package=mFLICA}{https://CRAN.R-project.org/package=mFLICA}. 
}
\Keywords{leadership, time series, coordination, pattern initiation}
\Plainkeywords{leadership, time Series, coordination, pattern initiation} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{50}
%% \Issue{9}
%% \Month{June}
%% \Year{2012}
%% \Submitdate{2012-06-04}
%% \Acceptdate{2012-06-04}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Chainarong Amornbunchornvej\\
  National Electronics and Computer Technology Center\\
  12120 Pathum Thani, Thailand\\
  E-mail: \email{chainarong.amo@nectec.or.th}\\
  URL: \url{https://orcid.org/0000-0003-3131-0370}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/512/507-7103
%% Fax: +43/512/507-2851

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section{Introduction}
%% Note: If there is markup in \(sub)section, then it has to be escape as above.


Leadership is defined as a process that leaders influence a group to achieve collective goals~\cite{hogg2001social,glowacki2015leadership}. In time series context, one of leadership definitions is pattern initiation. Leaders are initiators who initiate collective patterns (e.g. movement initiation, trends of stock closing prices) that everyone follows~\cite{Amornbunchornvej:2018:CED:3234931.3201406}. Collective patterns or \textit{coordination events} are emerging events of collective actions that aim to reach collective goals~\cite{malone1994interdisciplinary}. In time series context, coordination events occur when there exists some intervals such that some similar pattern occurs in all time series with possible different time delay for each time series~\cite{Amornbunchornvej:2018:CED:3234931.3201406}. A \textit{leader} of coordination event is a time series that initiates the pattern before others having this similar pattern with arbitrary time delays. 

% Leadership literature (story line in computation): flock, 2013 paper, flica,  mFLICA
Leadership literature in time series started in movement context. Leaders are defined as individuals who move in a front of a group in the flock model~\cite{andersson2008reporting}. Afterwards, the work by~\cite{kjargaard2013time} defined leaders as an individual who has the highest number of followers. The work defined that time series $A$ follows $B$ if a distance between a pattern of $A$ in current time and a pattern of $B$ in the past is small w.r.t. some time series distance measures, such as Dynamic Time Warping (DTW) \cite{sakoe1978dynamic}, cross-correlation~\cite{bracewell1965pentagram}, etc. However, the work was able to infer leaders only on a single coordination event and was unable to automatically detect coordination events.  Then, the leadership inference framework, FLICA, was proposed by~\cite{Amornbunchornvej:2018:CED:3234931.3201406} to infer leaders and their followers within time series that have multiple coordination events. The mFLICA framework~\cite{mFLICASDM18} was proposed to eliminate the limitation of FLICA. mFLICA can infer leaders and their followers within multiple coordination events that occur simultaneously, while FLICA cannot. This paper provides the details of \pkg{mFLICA} as an \proglang{R} package.

% add related R packages and frameworks in time series literature: 
% cross-correlation, dtw, granger causality/transfer entropy
% discuss causal inference vs. leadership inference
To infer a following relation between time series, DTW can be deployed for inferring a similar pattern between two time series. The \pkg{dtw} package~\cite{Rdtw} is deployed in \pkg{mFLCA} for DTW computation.

The related concepts of leadership inference on time series are Granger causality~\cite{granger1969investigating} and Transfer Entropy~\cite{schreiber-prl00,BEHRENDT2019100265}.  Both techniques can be used to infer whether time series $A$ is a predictor of time series $B$, which is similar to the following relation concept in leadership inference. Nevertheless, leadership inference aims to identity patterns that distributes among time series and their initiators (leaders) rather than finding predictors. In Comprehensive R Archive Network (CRAN), Granger causality framework can be found in \pkg{Imtest} package~\cite{GrangerR}, and transfer entropy is in \pkg{RTransferEntropy} package~\cite{BEHRENDT2019100265}.

In this paper, the details of  \pkg{mFLICA} package in R statistical software~\cite{Rprog} are provided. The current version of \pkg{mFLICA} is 0.1.1 on CRAN~\cite{RmFLICA}. \pkg{mFLICA} is a framework that is capable of:

\squishlist
\item {\bf Inferring coordination events:} the framework can infer and visualize coordination intervals that have high degrees of coordination; and
\item {\bf Inferring dynamics of leaders and followers:} the framework can infer leaders of coordination and their initiators that can be changed over time. %and 
\squishend

% Paper organization & version of package on CRAN
This paper is organized as follows. In Section~\ref{sec:def}, details of important definitions in leadership of coordination are provided. Section~\ref{sec:packageArch} provides the overview of \pkg{mFLICA} package architecture. Section~\ref{sec:inferDy} gives algorithms that are implemented in \pkg{mFLICA} as well as examples of how to use \pkg{mFLICA} for  inferring leadership of coordination  (e.g. factions, leadership dynamics) from a set of time series.  Lastly, Section~\ref{sec:con} provides the conclusion. 

\section{Definitions}
\label{sec:def}
% describe following relation, following network, dynamic following network, faction, and faction initiator
In this paper, a time series is referred as $T_i=(T_i(1),\dots,T_i(n))$ where $T_i(t)\in \mathbb{R}^d$ is an element of time series $T_i$ at time $t$, which is a $d$-dimensional vector of real numbers. A $\Delta$-time-shift $T_i^\Delta$ is a time series $T_i$ s.t. $T_i^\Delta(t+\Delta) = T_i(t)$. The time series $T_i^\Delta$ can be considered as time series $T_i$ that values are shifted forward into future.

Given two time series, the first building block of leadership in time series is the following relation that defines time series to be either a leader or follower. 

\begin{definition}[Following relation]
Given two $d$-dimensional time series $T_1$ and $T_2$, a similarity measure of time series $sim(\cdot,\cdot)$, and a threshold $\sigma$. A time series $T_1$ follows $T_2$ if there exist $\Delta>0$ s.t. $sim(T^\Delta_1,T_2)\geq \sigma$.
\end{definition}

In other words, a following relation represents a relation between time series s.t. one time series initiates some pattern, then another time series follows the similar pattern with the time delay $\Delta$. 

\begin{definition}[Following network]
Given a set of time series $S=\{T_1,\dots,T_m\}$. A following network $G=(V,E)$ is a directed acyclic graph (DAG) s.t. $V=\{v_1,\dots,v_m\}$ represents a set of nodes where $v_i$ is a node of time series $T_i$, and $E=\{e_{i,j}\}$ is a set of edges. If $T_i$ follows $T_j$, then there is a directed edge $e_{i,j} \in E$. 
\end{definition}

A following network represents following relations in a form of graph. If there is a high-level of coordination that many time series follow the same pattern, then a number of edges in a following network must be high. Hence, a network density below is used as a proxy of level of coordination.

\begin{equation}
    d(G) = \frac{|E|}{ {|V| \choose 2}}.
    \label{eq:netden}
\end{equation}

Where $d(G)\in [0,1]$, $|E|,|V|$ are numbers of edges and nodes in $G$ respectively. 

In real-word situation, there are more than one pattern that several time series might follow simultaneously. We call each group of time series that follow different pattern as a faction. In a following network, a faction is a network component s.t. all nodes within a faction have directed path(s) to a faction-leader node. We provide a definition of leaders and factions below.

\begin{definition}[Faction leader]
\label{def:leader}
Given a following network $G$, a faction leader is a node s.t. the out-degree is zero but the in-degree is greater than zero. 
\end{definition}

\begin{definition}[Faction members]
Given a following network $G$ and a faction-leader node $L$, members of $L$'s faction are nodes that have directed path(s) to $L$ in $G$.
\end{definition}

Lastly, factions and levels of coordination can be changed overtime. To capture leadership dynamics, the dynamic following network is defined below.

\begin{definition}[Dynamic following network]
\label{def:dynet}
Given a set of time series $S=\{T_1,\dots,T_m\}$, and a time window $\omega$.  Let $S_{[t_1,t_2]}$ be a revised set of $S$ where it contains only the time interval $[t_1,t_2]$ for each time series in $S$. 

A dynamic following network $\mathcal{G}=(G_1,\dots)$ is a sequence of following networks. At time $t$, a following network $G_t$ in $\mathcal{G}$ is a following network that is derived from $S_{[t,t+\omega]}$. 
\end{definition}

By measuring network densities of following networks in $\mathcal{G}$, we have a time series of network density $T_d=(d_1,\dots)$ where $d_t$ is a network density of $G_t$ in $\mathcal{G}$. The time series of network densities $T_d$ represents a dynamic of levels of coordination. 

% TODO: === faction size ratio definition
To measure dynamics of factions or sub groups, the faction size ratio is used to measure a faction size, which is defined below:


\begin{equation}
f(G,v_L)= \frac{|E_L|}{ {|V| \choose 2}}.
\label{eq:FZratio}
\end{equation}

Where $f(G,v_L)\in [0,1]$, $G$ is a following network, $v_L$ is a node of faction leader $L$, and $E_L$ is a number of edges connected between faction members.  For a dynamic following network $\mathcal{G}$, the time series of  faction size ratios of leader $L$'s faction represents dynamics of faction sizes; it captures patterns of $L$'s faction growing larger or becoming smaller over time. In the case of one leader, the faction size ratio in Eq.~\ref{eq:FZratio} is the same as the network density in Eq.~\ref{eq:netden}.


\section{Package architecture}
\label{sec:packageArch}

Given a set of time series and related parameters as inputs, \pkg{mFLICA} infers a dynamic following network, faction leader and members, as well as degrees of coordination over time.

\begin{figure}[ht!]
\centering
\includegraphics[width=1\columnwidth]{FIG/MainDiagram.png}
\caption{A high-level overview of \pkg{mFLICA} package architecture. }
\label{fig:mainFramework}
\end{figure}

 Figure~\ref{fig:mainFramework} provides an overview of the package architecture. The main function is \code{mFLICA()} that calls two functions: \code{getDynamicFollNet()} and \code{getFactions()}. The \code{getDynamicFollNet()} is used to infer a dynamic following network from a set of time series, while \code{getFactions()} is used to infer faction leaders and faction members for each time step in a dynamic following network. In \code{getDynamicFollNet()}, it calls \code{followingNetwork()} for inferring a following network for each time intervals to create a dynamic following network. The \code{followingNetwork()} function uses \code{followingRelation()} as a main engine to infer a following relation between a pair of time series to build a following network. Lastly, \code{getFactions()} calls \code{getReachableNodes()} to find faction members, which are nodes that have directed path(s) to the faction leader.

In this paper, we use a simulated dataset of 30 time series of movement from~\cite{mFLICASDM18} to demonstrate in examples of using \pkg{mFLICA} in leadership inference tasks. The dataset consists of two-dimensional time series of 30 individuals moving along the x-axis. The time series length is 800 time steps. There are three coordination events during the time interval [1,200] leading by individual ID1, the time interval [201,400] leading by ID2, and the time interval [400,600] leading by ID3.

In the next section, algorithms and examples regarding how to use \pkg{mFLICA} are provided for inferring leadership of coordination. 

\section{Inferring leadership of coordination}
\label{sec:inferDy}
% provide algorithm and example code for inferring the following relation, following network, dynamic following network, faction, and faction initiator
% Following relation with DTW


\subsection{Inferring following relations}
\begin{figure}[ht!]
\centering
\includegraphics[width=1\columnwidth]{FIG/Fig1.png}
\caption{(a) Leader and follower time series in x-axis. These time series of positions are generated based on the movement of individuals in a two-dimensional plane where a leader moved along x-axis.  A follower moved toward its leader in this plane. Both leader and follower have almost the same values in y-axis. (b) DTW cost matrix where darker-color shades represent higher distance. The black line is the optimal warping path between leader and follower, while the blue line is the diagonal line.}
\label{fig:FollTSEx}
\end{figure}


To infer a following relation between two time series, we deploy DTW to analyze an optimal warping path between two time series. Figure~\ref{fig:FollTSEx} shows simulated time series of movement from~\cite{mFLICASDM18}. In this event, a leader was moving toward x-axis while the follower followed its leader after some time delay.  

Figure~\ref{fig:FollTSEx} (a) illustrates the matching between two time series in x-axis. The cost matrix of DTW is shown in Figure~\ref{fig:FollTSEx} (b). Since the follower moved toward leader's previous positions, DTW optimal warping path matched leader's value at time $t$ to follower's value at some time $t+c$ where $c>0$.  Suppose $P=((r_1,c_1),\dots,(r_{|P|},c_{|P|}))$ is the optimal warping path (the black line in Figure~\ref{fig:FollTSEx} (b)) where $(r_i,c_i)$ represents that $i$th position $P$ is at the $r_i$th row and $c_i$th column in the DTW cost matrix. The $c_i-r_i$ is a time delay that the follower moved toward the same position as leader moved at time $r_i$th. By checking DTW cost matrix, a degree of following relation can be defined below.

\begin{equation}
\label{eq:foll}
    s(P_{L,F}) = \frac{\sum_{i \in P_{L,F}} (\textit{sign}(c_i-r_i))}{|P_{L,F}|}
\end{equation}
 
 Where $P_{L,F}$ is the optimal warping path of leader $L$, and follower $F$ inferred by DTW. A value of $s(P_{L,F}) \in [-1,1]$. Given a threshold $\sigma \in [0,1]$. If $s(P_{L,F}) \in [-1,-\sigma]$, then $L$ follows $F$.  If $s(P_{L,F}) \in [\sigma,1]$, then $F$ follows $L$. Otherwise, there is no following relation for $s(P_{L,F}) \in (-\sigma,\sigma)$.   The Example~\ref{ex:foll1} shows how we can use \pkg{mFLICA} to infer $s(P_{L,F})$.


\begin{exmp}
\label{ex:foll1}
Infer a following relation from two-dimensional time series of movement. We deploy simulated time series $TS$ from~\cite{mFLICASDM18} that included in this package. In this dataset, $TS[1,1:100,]$  is a two-dimensional time series of leader while $TS[2,1:100,]$ is a time series of follower. We use only the first 100 steps of time interval in this example. We run the code below for computing the optimal warping path between leader and follower.

\begin{lstlisting}[language=R]
R>library(mFLICA)
R>leader<-mFLICA::TS[1,1:100,] # Optimal warping path: obj$index2
R>follower<-mFLICA::TS[2,1:100,] # Optimal warping path: obj$index1
R>obj<-dtw(x=follower,y=leader,k=TRUE)   # run dtw from 'dtw' package
\end{lstlisting}

We called $dtw$ function and recorded the result in $obj$ where  $obj\$index1$ contains optimal warping path of a follower, and  $obj\$index2$ contains optimal warping path of a leader. This means the time series of follower at time $obj\$index1[i]$ is matched (most similar w.r.t. DTW matching) with the leader time series at time $obj\$index2[i]$. Then, we compute the average number of time steps until the follower reached the leader's previous positions.

\begin{lstlisting}[language=R]
R> mean( obj$index1 - obj$index2)
[1] 8.238462
\end{lstlisting}

On average, the follower required eight time steps to reach the its leader. Next, we calculate $s(P_{L,F})$ in Eq.~\ref{eq:foll}.

\begin{lstlisting}[language=R]
R>mean(sign( obj$index1 - obj$index2) ) 
[1] 0.9846154
\end{lstlisting}
This implies that there is a high degree of following relation between leader and follower ($s(P_{L,F})\approx 0.98$). In \pkg{mFLICA}, we implemented $followingRelation()$ function for computing $s(P_{L,F})$. We deploy Sakoe-Chiba Banding~\cite{sakoe1978dynamic} for speeding up DTW computation. We can set the limitation of band  via $lagWindow$ parameter. In this example, we set the band parameter at 10\% of the time series length ($lagWindow=0.1$). 

\begin{lstlisting}[language=R]
R> mFLICA::followingRelation(Y=follower,X=leader,lagWindow=0.1)$follVal
[1] 0.99
\end{lstlisting}
 We have $s(P_{L,F}) = 0.99$ in this example.
\end{exmp}

\subsection{Inferring following networks}
\begin{figure}[ht!]
\centering
\includegraphics[width=1\columnwidth]{FIG/Fig2.png}
\caption{Weighted adjacency matrices of the following networks from difference time intervals. Elements in matrices represent degrees of following derived from $s(P_{L,F})$ in Eq.~\ref{eq:foll} where leaders are rows and followers are columns (e.g. $(i,j)=0.5$ implies $j$ follows $i$ with degree $0.5$). A higher value (light blue) implies a higher degree of following relation. (a) The matrix from the interval [1,60], which has low degrees of coordination. (b) The matrix from the interval [61,120], which has high degrees of coordination leading by ID1. }
\label{fig:FollNetEx}
\end{figure}

After we know how to infer a following relation between two time series, the next step is to infer a following network from a set of multiple time series using \code{followingNetwork()} function in \pkg{mFLICA}. The pseudo code for the \code{followingNetwork()} is in Algorithm~\ref{algo:follNetFunc}. Given a set of time series and a threshold $\sigma$, the \code{followingNetwork()} function returns two adjacency matrices of the following network: \code{adjWeightedMat} and \code{adjBinMat}. The matrix \code{adjWeightedMat} is the adjacency matrix with weighted-directed edges, while \code{adjBinMat} is a binary version of \code{adjWeightedMat} where an edge weight can be  either zero (if the weight is below $\sigma$) or one (if the weight is greater than or equal $\sigma$). 

The Algorithm~\ref{algo:follNetFunc} computes $s(P_{i,j})$ in Eq.~\ref{eq:foll} for all pairs of time series but it computes either $s(P_{i,j})$ or $s(P_{j,i})$ only once since the results of these two cases are the same with the opposite sign. 



\setlength{\intextsep}{0pt}
\IncMargin{1em}
\begin{algorithm2e}
\caption{\code{followingNetwork()}}
\label{algo:follNetFunc}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{ a set of time series \code{TS} and a threshold $\sigma$ }
\Output{ \code{adjBinMat,adjWeightedMat} }
\begin{small}
\SetAlgoLined
\nl Let $m$ be a number of time series in \code{TS} and \code{adjBinMat,adjWeightedMat} are $m\times m$ matrices of zeroes\;
\nl \For{ \code{i} in $[1,m-1]$}{
\nl \For{ \code{j} in $[i+1,m]$}{
\nl  Compute $s(P_{i,j})$ for time series \code{TS[i]} as a leader and \code{TS[j]} as a follower.\;
     \uIf{$|s(P_{i,j})| \geq \sigma$ }
            {flag=1}
     \Else
            {flag=0}
     \uIf{$s(P_{i,j}) > 0$}
     {
     \nl set   \code{adjWeightedMat[j,i] = $s(P_{i,j})$} and \code{adjBinMat[j,i] = flag}
     }\Else{
     \nl set   \code{adjWeightedMat[i,j] =  $|s(P_{i,j})|$ }  and \code{adjBinMat[j,i] = flag}\;
     }
 }
}
Return \code{adjBinMat,adjWeightedMat}\;
\end{small}
\end{algorithm2e}\DecMargin{1em}

Next, we show how to use \code{followingNetwork()} in \pkg{mFLICA} to infer an adjacency matrix of a following network.

\begin{exmp}
\label{ex:follNet1}
Infer adjacency matrices of following networks by using a set of simulated time series $TS$, which contains 30 trajectories of movement in two-dimensional plane along x-axis. The low-coordination interval $[1,60]$ and high-coordination interval $[61,120]$ are chosen in the example.  We set $\sigma = 0,5$ for this example.

\begin{lstlisting}[language=R]
R>library(mFLICA)
R>mat1<-followingNetwork(TS=TS[,1:60,],sigma=0.5)$adjWeightedMat
R>mat2<-followingNetwork(TS=TS[,61:120,],sigma=0.5)$adjWeightedMat
\end{lstlisting}

Figure~\ref{fig:FollNetEx} illustrates the adjacency matrices from both intervals. The weighted adjacency matrix \code{mat1} at Figure~\ref{fig:FollNetEx} (a) is computed from the time interval $[1,60]$ when the group initiated movement. In Figure~\ref{fig:FollNetEx} (b),  the weighted adjacency matrix \code{mat2} is computed from  the time interval $[61,120]$ when everyone followed its leader ID1, which implies it is a high-coordination event.  \pkg{mFLICA} provides \code{getADJNetDen()} for computing a network density from an adjacency matrix. Based on the result, \code{mat1} has a lower network density than \code{mat2}'s network density. The network densities can be computed below.  

\begin{lstlisting}[language=R]
R>getADJNetDen(mat1)
[1] 0.5559004
R>getADJNetDen(mat2)
[1] 0.7961686
\end{lstlisting}

In Figure~\ref{fig:FollNetEx} (b), in the row of ID1, all individuals have high degrees of following ID1, which implies that ID1 is a leader in this interval. In contrast, there are no individuals followed by the majority in Figure~\ref{fig:FollNetEx} (a), which implies that this interval has low degrees of coordination.

\end{exmp}

In the next step, we use \code{followingNetwork()} to infer a dynamic following network. Given a set of time series \code{TS} that has its time length at $n$, and the time window $\omega$, by Definition~\ref{def:dynet}, we can use the sliding window technique to compute a dynamic following network from \code{followingNetwork()} by dividing a set of time series \code{TS} into sub-intervals s.t. each sub interval has the time length $\omega$. We can start computing a following network at time interval $[t,t+\omega]$, then $[t+1,t+1+\omega]$, and so on. However, sliding from one interval to another only one time step might require expensive computational cost. 




\setlength{\intextsep}{0pt}
\IncMargin{1em}
\begin{algorithm2e}
\caption{\code{getDynamicFollNet()}}
\label{algo:DyfollNetFunc}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{ a set of time series \code{TS}, a time window $\omega$, a time shift $\delta$, and a threshold $\sigma$ }
\Output{  \code{dyNetWeightedMat,dyNetWeightedDensityVec}, \code{dyNetBinMat,dyNetBinDensityVec} }
\begin{small}
\SetAlgoLined
\nl Let $n$ be a length of time series\;
\nl Let $s_1,\dots,s_k$ be starting times of $k$ intervals where $s_{i+1}=s_{i} + \delta$ and $s_k= max_{c \in \mathbb{N}}(c\times\delta+\omega\leq n)$\;
\For{ \code{i} in $\{1,\dots,k\}$}{
\nl Let \code{TS}' be a revised set of \code{TS} where it contains only the time interval $[s_i,s_i+\omega]$ for each time series in \code{TS}. \;
\nl Compute \code{followingNetwork(\code{TS}',$\sigma$)} to get adjacency matrices \code{adjBinMat,adjWeightedMat}\;
\nl Compute network densities for both \code{adjBinMat,adjWeightedMat} by Eq.~\ref{eq:netden}\;
\nl Record  \code{adjBinMat,adjWeightedMat} to \code{dyNetBinMat,dyNetWeightedMat} as adjacency matrices of the dynamic network for the time interval $[s_i,s_i+\delta]$\;
\nl Record the network densities of  \code{adjBinMat,adjWeightedMat} to \code{dyNetBinDensityVec,dyNetWeightedDensityVec} for the time interval $[s_i,s_i+\delta]$\;
}
\nl Return \code{dyNetWeightedMat,dyNetWeightedDensityVec}, \code{dyNetBinMat,dyNetBinDensityVec}\;
\end{small}
\end{algorithm2e}\DecMargin{1em}

Hence, \pkg{mFLICA} provides the time shift parameter $\delta \in [1,\omega]$ to allow users to adjust the number of time steps between a previous interval and the next one.  The \code{getDynamicFollNet()} in Algorithm~\ref{algo:DyfollNetFunc} is a function for inferring a dynamic following network from a set of time series in \pkg{mFLICA}. The algorithm separates a set of time series $TS$ into $k$ sub-intervals where each interval has a length $\omega$. For each interval, the algorithm computes a following network using Algorithm~\ref{algo:follNetFunc}, then it records the results of the following network into time series of adjacency matrices $dyNetWeightedMat$ and its binary version $dyNetBinMat$ as well as computing their network densities using Eq.~\ref{eq:netden}. After finish computing following networks for all sub-intervals, the algorithm returns the results. 

The next example provides the details how to use \pkg{mFLICA} to compute a dynamic following network.

\begin{exmp}
In this example, we use the set of simulated time series \code{TS}, which has the time length at 800 time steps. In this dataset, there are three coordination events: [1,200], [201,400], and [401,600]. We set the time window $\omega=60$, the time shift $\delta=6$, and the threshold $\sigma=0.5$. The next commands are used to infer our dynamic following network of \code{TS}.

\begin{lstlisting}[language=R]
R>library(mFLICA)
R>obj1<-getDynamicFollNet(TS=mFLICA::TS[,1:800,],timeWindow=60,timeShift = 6,sigma=0.5)
\end{lstlisting}

Suppose we want to know the following degree for ID19 follows ID1 at time step 150, we can use the command below.
\begin{lstlisting}[language=R]
R>obj1$dyNetWeightedMat[19,1,150]
[1] 0.9833333 # the following degree for ID19 follows ID1 at time step 150
\end{lstlisting}
We can query the network density at time step 150 with the command below.
\begin{lstlisting}[language=R]
R>obj1$dyNetWeightedDensityVec[150]
[1] 0.7755939
\end{lstlisting}

We can plot the time series of network density using the \code{plotMultipleTimeSeries} function implemented in \pkg{mFLICA} below. 

\begin{lstlisting}[language=R]
R>plotMultipleTimeSeries(TS=obj1$dyNetWeightedDensityVec, strTitle="Network Dnesity")
\end{lstlisting}

Figure~\ref{fig:DyNetDen} shows the result of the plot. The plot shows that there are three coordination events that have high network densities (high degrees of coordination): [1,200], [201,400], and [401,600], which are consistent with our ground truth.

\begin{figure}[ht!]
\centering
\includegraphics[width=1\columnwidth]{FIG/DyNetDen.png}
\caption{Time series of network densities of a dynamic following network from simulated time series \code{TS} in \pkg{mFLICA} package. The plot shows that there are three coordination events that have high network densities (high degrees of coordination): [1,200], [201,400], and [401,600], which are consistent with our ground truth. }
\label{fig:DyNetDen}
\end{figure}

\end{exmp}




\subsection{Inferring leadership dynamics}
\label{sec:leadership}
% provide faction inference
After having a dynamic following network, the next step is to infer leaders of factions and members of factions. 

The Algorithm~\ref{algo:getFactions} provides the details of \code{getFactions()} implemented in \pkg{mFLICA} for inferring faction leaders, faction members, and faction size ratios. For each time step, a network structure of a following network at time $t$ is analyzed. According to Definition~\ref{def:leader}, nodes of leaders are inferred as nodes in a following network that have zero out-degree. Then, for each leader node $L$, nodes that are members of $L$'s faction are identified by transitive closure property.
If there exists a path from any node $v$ to $L$, then $v$ is a member of $L$'s faction. 


\setlength{\intextsep}{0pt}
\IncMargin{1em}
\begin{algorithm2e}
\caption{\code{getFactions()}}
\label{algo:getFactions}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{ A binary adjacency matrix \code{adjBinMat} }
\Output{ \code{leaders,factionMembers,factionSizeRatio} }
\begin{small}
\SetAlgoLined
\nl  Infer zero-out-degree nodes in \code{adjBinMat} and keep them in \code{leaders}\;
\For{ \code{leader} in \code{leaders}}{
    \nl Finding all nodes that are reachable to \code{leader} in \code{adjBinMat} using Breadth First Search (BFS) algorithm\;
    \nl Keep these nodes as faction members of \code{leader} in \code{factionMembers[leader]}\;
    \nl Computing faction-size ration in Eq.~\ref{eq:FZratio} and keep it in \code{factionSizeRatio[leader]}\;
}
Return \code{leaders,factionMembers,factionSizeRatio}\;
\end{small}
\end{algorithm2e}\DecMargin{1em}

Hence, a faction is a tree with reversed directed paths in a following network s.t. all node members have a path to its root (leader). The step of inferring faction members can be done by applying Breadth-First Search (BFS) algorithm on an adjacency matrix of a following network. The BFS algorithm is implemented in \code{getReachableNodes()} in the package.  After we have all factions within a following network, the last step is to measure the size of each faction using a faction size ratio in Eq.~\ref{eq:FZratio}. In the next example, we provide the way to use \pkg{mFLICA} to infer faction leaders and their members using \code{getFactions()}.


\begin{exmp}
In this example, we use the interval [25,45] to demonstrate the time when there are more than one factions occur simultaneously. After having a following network, \code{getFactions()} takes a binary version of adjacency matrix as its input.
\begin{lstlisting}[language=R]
R>library(mFLICA)
R>mat1 <-followingNetwork(TS=TS[,25:45,], sigma =0.95)$adjBinMat
R>out<-getFactions(adjMat=mat1)
R>out$leaders # show leader IDs
[1] 1 11
\end{lstlisting}
The code above shows that there are two faction leaders in the interval [25,45]: ID1 and ID11. This implies that there are two factions. The next step is to query faction members of ID1's faction as well as its faction size ratio.
\begin{lstlisting}[language=R]
R>L1<-out$leaders[1] # leader ID1
R>out$factionMembers[[1]] # show faction members
[1]  1  2  3  4  5  6  7  8  9 10 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 
R>out$factionSizeRatio[L1] # show faction size ratio
[1] 0.5034483
\end{lstlisting}
Note that a leader is also a faction member itself. Since there are 30 individuals, almost everyone is a member of ID1's faction. However, the faction size ratio at 0.5 indicates that faction members are not coordinated following the same pattern yet. The next one is the code for querying details about a faction leading by ID11.

\begin{lstlisting}[language=R]
R>L1<-out$leaders[2] # leader ID11
R>out$factionMembers[[2]] # show faction members
[1]  11  7 10 13 14 15 16 18 19 20 21 22 23 24 26 28 30 
R>out$factionSizeRatio[L2] # show faction size ratio
[1] 0.1632184
\end{lstlisting}
We can see that there are a few number of members in this faction. Note that one individual can belong to more than one faction since the individual might follow some pattern that seems partially similar to several leaders' patterns.
\end{exmp}

Lastly, we can use \code{mFLICA()} to infer a dynamic following network and dynamics of factions from a set of time series. Algorithm~\ref{algo:mFLICAmainFunc} provides the details of \code{mFLICA()} implementation. First, \code{mFLICA()} computes a dynamic following network and its time series of network densities from a set of time series w.r.t. given parameters. Then, for each time step, \code{mFLICA()} infers faction leaders, faction members, and faction size ratios from the dynamic following network.

\setlength{\intextsep}{0pt}
\IncMargin{1em}
\begin{algorithm2e}
\caption{\code{mFLICA()}}
\label{algo:mFLICAmainFunc}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{ a set of time series \code{TS}, a time window $\omega$, a time shift $\delta$, and a threshold $\sigma$ }
\Output{ \code{dyNetWeightedMat,dyNetWeightedDensityVec}, \code{dyNetBinMat,dyNetBinDensityVec}, \code{TSleaders,TSfactionMembers,TSfactionSizeRatio} }
\begin{small}
\SetAlgoLined
\nl Computing a dynamic following network using \code{getDynamicFollNet()}\;
\For{ \code{t} in \code{[1,m]]}}{
\nl Let \code{dyNetBinMat[t]} be an adjacency matrix at time \code{t}\;
\nl Computing faction members, leaders, and faction size ratios using \code{getFactions(dyNetBinMat[t])}\;
\nl Keep faction members in \code{TSfactionMembers[t]}, leaders in \code{TSleaders[t]}, and faction size ratio in \code{TSfactionSizeRatio[t]}\;
}
Return \code{dyNetWeightedMat,dyNetWeightedDensityVec}, \code{dyNetBinMat,dyNetBinDensityVec}, \code{TSleaders,TSfactionMembers,TSfactionSizeRatio} \;
\end{small}
\end{algorithm2e}\DecMargin{1em}

The next example shows the details of using \code{mFLICA()} to infer dynamics of factions.

\begin{exmp}
In this example, we show how to use \pkg{mFLICA} to infer dynamics of factions. In other words, we would like to find changes of faction members and faction leaders over time. Given a set of time series \code{TS} as an input along with related parameters: time window $\omega=60$, time shift $\delta=6$, and the threshold $\sigma=0.5$, we run \code{mFLICA()} below.
\begin{lstlisting}[language=R]
R>library(mFLICA)
R>obj1<-mFLICA(TS=mFLICA::TS[,1:800,],timeWindow=60,timeShift = 6,sigma=0.5)
\end{lstlisting}
All results of faction inference are in \code{obj1}. Here, we focus on a set of time series of faction size ratios \code{obj1\$factionSizeRatioTimeSeries} where \code{obj1\$factionSizeRatioTimeSeries[i,t]} is a faction size ratio of a faction leading by ID\code{i} at time \code{t}. We can plot the time series of faction size ratios using \code{plotMultipleTimeSeries} below.

\begin{lstlisting}[language=R]
R>plotMultipleTimeSeries(TS=obj1$factionSizeRatioTimeSeries, strTitle="Faction Size Ratios")
\end{lstlisting}
The result of the plot is in Figure~\ref{fig:FactionDy}. According to the ground truth for this simulated dataset mentioned in Section~\ref{sec:packageArch}, there are three coordination events. First, during the time interval [1,200], ID1 is a sole leader who leads its faction of 30 individuals. Then, ID2 leads the faction for the time interval [201,400]. Afterward, ID3 leads the faction during the interval [401,600]. Finally, the group slows down and stop moving. The result in Figure~\ref{fig:FactionDy} reflexes this ground truth. ID1 has its high faction size ratios during [1,200], ID2's faction continues to have high faction size ratios during [201,400]. Lastly, ID3's faction has high faction size ratios during [401,600]. No factions have high faction size ratios during [601,800].
\end{exmp}


\begin{figure}[ht!]
\centering
\includegraphics[width=1\columnwidth]{FIG/FactionDynamics.png}
\caption{Time series of faction size ratios. Each time series of faction sizes ratios is represented by ID (TS\#ID) of its faction leader.  }
\label{fig:FactionDy}
\end{figure}

\section{Conclusion}
\label{sec:con}
In this paper, the details of \pkg{mFLICA} package for inferring leadership of coordination from time series are provides. Leaders are defined as individuals who initiate some patterns and others follow the same patterns with some time delays. A following relation between time series can be detected by analyzing an optimal warping path of Dynamic Time Warping (DTW), which is the main component that \pkg{mFLICA} deploys. 

Given a set of time series and related parameters, the \pkg{mFLICA} package can infer a following relation between two time series, following networks, faction leaders, faction members, degrees of coordination, and faction size ratios for each time step. 

The network densities inferred by \pkg{mFLICA} tell us regarding the magnitude of coordination: how many time-series individuals follow the same pattern in a given time interval. The faction size ratios provide information regarding faction dynamics; the changes of faction leaders, and/or faction members over time. We provided the examples of how to use \pkg{mFLICA} for solving many tasks in leadership inference. Our framework can be applied to any multivariate time series. All figures and results can be reproduced using the R notebook at \href{https://github.com/DarkEyes/mFLICA/blob/master/exp/JSSnotebook.Rmd}{https://github.com/DarkEyes/mFLICA/blob/master/exp/JSSnotebook.Rmd}

%\bibliographystyle{jss}
\bibliography{ChaiRef} 

\end{document}
